[{"/home/qdizon/Programming/cantus-firmus-test-suite/src/index.js":"1","/home/qdizon/Programming/cantus-firmus-test-suite/src/App.js":"2","/home/qdizon/Programming/cantus-firmus-test-suite/src/state/main/mainProvider.js":"3","/home/qdizon/Programming/cantus-firmus-test-suite/src/state/main/state.js":"4","/home/qdizon/Programming/cantus-firmus-test-suite/src/state/main/setters.js":"5","/home/qdizon/Programming/cantus-firmus-test-suite/src/state/main/methods.js":"6","/home/qdizon/Programming/cantus-firmus-test-suite/src/state/main/constants.js":"7","/home/qdizon/Programming/cantus-firmus-test-suite/src/state/main/reducers.js":"8","/home/qdizon/Programming/cantus-firmus-test-suite/src/cantus-firmus/index.js":"9","/home/qdizon/Programming/cantus-firmus-test-suite/src/cantus-firmus/src/index.js":"10"},{"size":271,"mtime":1612262334365,"results":"11","hashOfConfig":"12"},{"size":528,"mtime":1612261119630,"results":"13","hashOfConfig":"12"},{"size":502,"mtime":1612347768491,"results":"14","hashOfConfig":"12"},{"size":70,"mtime":1612261741647,"results":"15","hashOfConfig":"12"},{"size":76,"mtime":1612261741647,"results":"16","hashOfConfig":"12"},{"size":76,"mtime":1612261741647,"results":"17","hashOfConfig":"12"},{"size":82,"mtime":1612261741647,"results":"18","hashOfConfig":"12"},{"size":79,"mtime":1612261741647,"results":"19","hashOfConfig":"12"},{"size":42853,"mtime":1612348070024,"results":"20","hashOfConfig":"12"},{"size":25892,"mtime":1612263017180,"results":"21","hashOfConfig":"12"},{"filePath":"22","messages":"23","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},"2xgudt",{"filePath":"25","messages":"26","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"27","messages":"28","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"29","messages":"30","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"31","messages":"32","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"33","messages":"34","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"35","messages":"36","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"37","messages":"38","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"39","messages":"40","errorCount":10,"warningCount":25,"fixableErrorCount":0,"fixableWarningCount":1,"source":null},{"filePath":"41","messages":"42","errorCount":1,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"43"},"/home/qdizon/Programming/cantus-firmus-test-suite/src/index.js",[],["44","45"],"/home/qdizon/Programming/cantus-firmus-test-suite/src/App.js",[],"/home/qdizon/Programming/cantus-firmus-test-suite/src/state/main/mainProvider.js",[],"/home/qdizon/Programming/cantus-firmus-test-suite/src/state/main/state.js",[],"/home/qdizon/Programming/cantus-firmus-test-suite/src/state/main/setters.js",[],"/home/qdizon/Programming/cantus-firmus-test-suite/src/state/main/methods.js",[],"/home/qdizon/Programming/cantus-firmus-test-suite/src/state/main/constants.js",[],"/home/qdizon/Programming/cantus-firmus-test-suite/src/state/main/reducers.js",[],"/home/qdizon/Programming/cantus-firmus-test-suite/src/cantus-firmus/index.js",["46","47","48","49","50","51","52","53","54","55","56","57","58","59","60","61","62","63","64","65","66","67","68","69","70","71","72","73","74","75","76","77","78","79","80"],"/home/qdizon/Programming/cantus-firmus-test-suite/src/cantus-firmus/src/index.js",["81","82","83","84","85"],"import React, { createContext, PureComponent, useContext, useMemo } from \"react\";\n\n// const React = require('react')\n// const { createContext, Component } = React\n\n// ========================== HELPER METHODS ==========================\n\nconst bindMethods = (methods, self) => {\n    /* \n    takes an object of methods and binds them to a given \"self\"\n    */\n    const bound = {}\n    for (let method in methods) {\n        bound[method] = methods[method].bind(self)\n    }\n    return bound;\n}\n\n\nconst formatStateName = (name, prefix = \"\") => {\n    /* \n    Takes an object key (name) as an input, and returns that name capitalized with the word \"set\" prepended to it.\n    If the word already starts with a capital letter (or and underscore _), returns null. \n\n    This functionality allows for standard key names to automatically get setters, while also allowing for users to specify key names that should not be changed or should not get setters. \n    */\n    name = name.split(\"\");\n\n    if (name[0] === name[0].toUpperCase()) return null;\n\n    name[0] = name[0].toUpperCase()\n    return prefix + name.join(\"\");\n}\n\nconst getNestedRoutes = (state) => {\n    /* \n    takes a state object and returns paths (as arrays) of all routes, including nested object structures\n    */\n    const paths = []\n\n    const traverse = (element, currentPath = []) => {\n        // base cases\n        if (typeof element !== \"object\" || Array.isArray(element) || !element) {\n            currentPath.length > 1 && paths.push(currentPath);\n            return;\n        }\n\n        currentPath.length > 1 && paths.push(currentPath)\n        for (let key of Object.keys(element)) {\n            traverse(element[key], [...currentPath, key])\n        }\n    }\n    traverse(state)\n    return paths;\n}\n\n\nconst nestedSetterFactory = (state, nsPath) => (newValue) => {\n    let copy = { ...state };\n    let currentPath = copy;\n    let key;\n    for (let i = 0; i < nsPath.length; i++) {\n        key = nsPath[i];\n\n        if (i < nsPath.length - 1) { // if not on the last key in the provided path\n            currentPath[key] = { ...currentPath[key] }\n        } else { // if on last key, reassign value to the new value\n            currentPath[key] = newValue\n        }\n\n        currentPath = currentPath[key]\n    }\n\n    return copy\n}\n\nconst getNestedValue = (state, nsPath) => {\n    let copy = { ...state },\n        currentPath = copy,\n        key;\n\n    for (let i = 0; i < nsPath.length; i++) {\n        key = nsPath[i]\n        if (i === nsPath.length - 1) { // we have reached the desired nested level\n            return currentPath[key]\n        }\n        currentPath = currentPath[key]\n    }\n}\n\n\nconst createStateSetters = (state, ignoredSetters = [], nestedSetters = false, setters = {}) => {\n    /* \n    iterates through a provided state object, and takes each key name (state value) and creates a setter method for that value. \n    Following the standard React convention, a key called \"myKey\" would get a setter method called \"setMyKey\".\n    */\n\n    let formattedName;\n    for (let s in state) {\n        formattedName = formatStateName(s, \"set\");\n\n        if (formattedName && !ignoredSetters.includes(s)) {\n            setters[formattedName] = async function (value, cb = () => {}) {\n                if(typeof value === \"function\"){\n                    return new Promise(async resolve => {\n                        resolve(await this.setState(value, cb))\n                    })\n                } else {\n                    const newState = {}\n                    newState[s] = value;\n                    return new Promise(async resolve => {\n                        resolve(await this.setState(newState, cb))\n                    })\n                }\n            }\n        }\n    }\n\n    // handle creation of nested setters\n    if (nestedSetters) {\n        const nestedPaths = getNestedRoutes(state);\n        let nestedName;\n        for (let nsPath of nestedPaths) {\n            nestedName = nsPath.join(\"_\");\n            formattedName = formatStateName(nestedName, \"set\")\n            if (formattedName && !ignoredSetters.includes(nestedName)) {\n                setters[formattedName] = async function (value) {\n                    const newState = nestedSetterFactory(this.state, nsPath)(value) // reassign the nested value and return whole state object;\n                    return new Promise(async resolve => {\n                        resolve(await this.setState(newState))\n                    })\n                }\n            }\n        }\n    }\n\n    return setters;\n}\n\nconst createStateGetters = (state, ignoredGetters = [], nestedGetters = true, getters = {}) => {\n    /* \n    iterates through a provided state object and creates getter wrapper functions to retrieve the state (rather than grabbing directly from the state object)\n    */\n    let formattedName;\n    for (let s in state) {\n        formattedName = formatStateName(s, \"get\");\n        if (formattedName && !ignoredGetters.includes(s)) {\n            getters[formattedName] = function () {\n                return this.state[s]\n            }\n        }\n    }\n\n    // handle creation of nested getters\n    if (nestedGetters) {\n        const nestedPaths = getNestedRoutes(state);\n        let nestedName;\n        for (let nsPath of nestedPaths) {\n            nestedName = nsPath.join(\"_\");\n            formattedName = formatStateName(nestedName, \"get\")\n            if (formattedName && !ignoredGetters.includes(nestedName)) {\n                getters[formattedName] = function () {\n                    return getNestedValue(this.state, nsPath)\n                }\n            }\n        }\n    }\n\n    return getters\n}\n\nconst createParamsString = (params = {}) => {\n    let str = \"\"\n    for (let param of Object.keys(params)) {\n        str += (param + \"=\" + params[param] + \",\")\n    }\n    return str;\n}\n\nconst cleanState = (state, privatePaths) => {\n\n    /* \n    takes a state object and list of private paths as inputs, and returns the state with the private paths removed. \n    */\n    const cleaned = { ...state } // make a copy of state\n    let np, nestedPath;\n    for (let path of privatePaths) {\n        if (Array.isArray(path)) { // if provided with a nested path, traverse down and delete final entry\n            nestedPath = cleaned;\n            for (let i = 0; i < path.length; i++) {\n                np = path[i];\n                try {\n                    if (i === path.length - 1) {\n                        delete nestedPath[np]\n                    } else {\n                        nestedPath = nestedPath[np]\n                    }\n                } catch (err) { // if a provided key along the path does not exist, inform user\n                    console.error(`Provided key, [\"${path[i - 1]}\"] does not exist\\n\\nFull error message reads:\\n\\n`, err)\n                    break;\n                }\n            }\n        } else {\n            delete cleaned[path];\n        }\n    }\n\n    return cleaned;\n\n}\n\nconst createReducerDispatchers = (reducers) => {\n    const reducerMethods = {}\n    for (let r in reducers) {\n        // console.log(r)\n        reducerMethods[r] = (state, action) => {\n            this.setState(reducers[r](state, action))\n        }\n\n    }\n\n    // console.log(reducerMethods.stateReducer)\n\n    return reducerMethods\n}\n\n\n// ========================== DEFAULT OPTIONS ==========================\n\n\nconst DEFAULT_OPTIONS = {\n    dynamicSetters: true,\n    dynamicGetters: true,\n    allowSetterOverwrite: true,\n    developmentWarnings: true,\n    overwriteProtectionLevel: 1,\n    nestedSetters: false,\n    nestedGetters: true\n}\n\nconst DEFAULT_STORAGE_OPTIONS = {\n    name: null,\n    unmountBehavior: \"all\",\n    initializeFromLocalStorage: false,\n    subscriberWindows: [],\n    removeChildrenOnUnload: true,\n    clearStorageOnUnload: true,\n    privateStatePaths: []\n}\n\n\n// ========================== CANTUS_FIRMUS CLASS ==========================\n\nclass CantusFirmus {\n    constructor(state, options = {}) {\n        this.context = createContext(null);\n        this.state = state;\n\n        this.setters = {};\n        this.getters = {};\n        this.reducers = {};\n        this.constants = {};\n        this.methods = {};\n        this.namespacedMethods = {};\n\n        // OPTIONS\n        this.options = { ...DEFAULT_OPTIONS, ...options }\n\n        this.dynamicSetters = this.options.dynamicSetters\n        this.dynamicGetters = this.options.dynamicGetters\n        this.allowSetterOverwrite = this.options.allowSetterOverwrite\n        this.developmentWarnings = this.options.developmentWarnings\n        this.overwriteProtectionLevel = this.options.overwriteProtectionLevel\n        this.nestedSetters = this.options.nestedSetters\n\n        // initialize blank storageOptions (will be populated later if user chooses)\n        this.storageOptions = {}\n\n        // Local Storage Connection\n        this.bindToLocalStorage = false\n\n\n    }\n\n    addCustomSetters(setters) {\n        this.setters = setters\n    }\n\n    ignoreSetters(settersArr) {\n        this.ignoredSetters = settersArr || []\n    }\n\n    addCustomGetters(getters) {\n        this.getters = getters\n    }\n\n    ignoreGetters(gettersArr) {\n        this.ignoredGetters = gettersArr || []\n    }\n\n    addReducers(reducers) {\n        this.reducers = reducers\n    }\n\n    addConstants(newConstants) {\n        this.constants = { ...this.constants, ...newConstants }\n    }\n\n    addMethods(methods) {\n        this.methods = methods;\n    }\n\n    addNamespacedMethods(methodsMap){\n        this.namespacedMethods = methodsMap;\n    }\n\n    rename(nameMap) {\n        this.renameMap = nameMap || {}\n    }\n\n    connectToLocalStorage(options = {}) {\n        this.bindToLocalStorage = true\n        this.storageOptions = { ...DEFAULT_STORAGE_OPTIONS, ...options }\n\n        // if no name is specified, throw an error, as this is a required field to manage multiple localStorage instances\n        if (!this.storageOptions.name) throw new Error(\"When connecting your cf instance to the local storage, you must provide an unique name (string) to avoid conflicts with other local storage parameters.\")\n\n        // default the provider window name to the localStorage name if providerWindow param not given\n        this.storageOptions.providerWindow = this.storageOptions.providerWindow || this.storageOptions.name\n\n        // if user has specified to load state from local storage (this only impacts the provider window)\n        if (this.storageOptions.initializeFromLocalStorage) {\n            if (window.localStorage.getItem(this.storageOptions.name)) this.state = {\n                ...this.state,\n                ...JSON.parse(window.localStorage.getItem(this.storageOptions.name))\n            }\n        }\n\n        // if the window is a subscriber window, automatically initialize from local storage\n        // Note that the implementation here is slightly different from the stand initializeFromLocalStorage above because if a state resource is desginated as private, subscriber windows should not initialize default values for those private resources.\n        if (this.storageOptions.subscriberWindows.includes(window.name)) {\n            if (window.localStorage.getItem(this.storageOptions.name)) {\n                this.state = JSON.parse(window.localStorage.getItem(this.storageOptions.name))                \n            }\n        }\n\n        if (!window.name && this.storageOptions.providerWindow) window.name = this.storageOptions.providerWindow\n\n\n\n    }\n\n    // _clearStateFromStorage() {\n    //     function handleUnload(e){\n    //         this.storageOptions.name && localStorage.removeItem(this.storageOptions.name)\n    //         if(this.storageOptions.removeChildrenOnUnload){\n\n    //         }\n    //     }\n\n    //     handleUnload = handleUnload.bind(this)\n\n    //     window.onbeforeunload = handleUnload\n    //     window.onunload = handleUnload\n\n    // }\n\n    createProvider() {\n        // copy instance properties/methods\n        const Context = this.context;\n        const state = this.state;\n        let constants = this.constants\n        let reducers = this.reducers\n        let methods = this.methods;\n        let namespacedMethods = this.namespacedMethods;\n        let ignoredSetters = this.ignoredSetters;\n        let ignoredGetters = this.ignoredGetters;\n        let renameMap = this.renameMap || {}\n\n        const bindToLocalStorage = this.bindToLocalStorage;\n        const storageOptions = this.storageOptions\n        let setters,\n            getters;\n\n        // initialize local storage with state\n        // also check to make sure that any state paths marked as private are removed before setting local storage\n        if (storageOptions.name) {\n            const authorizedState = cleanState(state, storageOptions.privateStatePaths)\n            storageOptions.name && localStorage.setItem(storageOptions.name, JSON.stringify(authorizedState))\n        }\n\n\n        // Pre class definition setup\n\n        // GETTER CREATION\n        getters = this.dynamicGetters ? { ...createStateGetters(state, ignoredGetters, this.nestedGetters), ...this.getters } : { ...this.getters }\n\n        // SETTER CREATION\n        if (this.allowSetterOverwrite) {\n            setters = this.dynamicSetters ? { ...createStateSetters(state, ignoredSetters, this.nestedSetters), ...this.setters } : { ...this.setters };\n        } else {\n            let dynamicSetters = createStateSetters(state, ignoredSetters)\n            const dynamicKeys = Object.keys(dynamicSetters);\n\n            for (let key of Object.keys(this.setters)) {\n                if (dynamicKeys.includes(key)) {\n\n                    if (this.developmentWarnings) {\n\n                        this.overwriteProtectionLevel === 1\n                            &&\n                            console.warn(`The user defined setter, '${key}', was blocked from overwriting a dynamically generated setter of the same name. To change this behavior, set allowSetterOverwrite to true in the CantusFirmus options.`)\n\n                        if (this.overwriteProtectionLevel >= 2) {\n                            throw new Error(`The user defined setter, '${key}', was blocked from overwriting a dynamically generated setter of the same name. To change this behavior, set allowSetterOverwrite to true in the CantusFirmus options.`)\n                        }\n\n\n                    }\n                    delete this.setters[key]\n                }\n            }\n            setters = this.dynamicSetters ? { ...createStateSetters(state, ignoredSetters, this.nestedSetters), ...this.setters } : { ...this.setters };\n        }\n\n        // define Provider class component\n        class Provider extends PureComponent {\n            constructor(props) {\n                super(props);\n                this.state = state\n                this.setters = bindMethods(setters, this);\n                this.getters = bindMethods(getters, this);\n\n                // set this.reducers to the reducers added in the CantusFirmus Class \n                this.reducers = reducers\n                // bind generateDispatchers\n                this.generateDispatchers = this.generateDispatchers.bind(this);\n                // Create reducers that are copies in name of the previously added reducers\n                // Then, give a dispatch method to each that will execute the actual reducer\n                this.reducersWithDispatchers = this.generateDispatchers(reducers)\n\n                // Bind methods\n                this.methods = bindMethods(methods, this);\n                // create and bind namespaced methods\n                this._boundNamespacedMethods = {};\n                for(let [key, methodGroup] of Object.entries(namespacedMethods)){\n                    this._boundNamespacedMethods[key] = bindMethods(methodGroup, this)\n                }\n\n                this.bindToLocalStorage = bindToLocalStorage;\n                this.storageOptions = storageOptions;\n\n                this.updateStateFromLocalStorage = this.updateStateFromLocalStorage.bind(this);\n\n                // Save master version of setState prior to reassignment\n                this.setStateMaster = this.setState;\n\n                // Reassign setState function to return a promise, and by default, handle localStorage changes\n                this.setState = function (state, callback = () => { }) {\n                    return new Promise(resolve => {\n                        this.setStateMaster(state, () => {\n                            // handle local storage updates to state\n                            if (this.bindToLocalStorage) {\n                                if (this.storageOptions.privateStatePaths.length && window.name === this.storageOptions.providerWindow) { // if there are any private paths that need to be removed (only proceed if fired from the provider window)\n                                    const authorizedState = cleanState(this.state, this.storageOptions.privateStatePaths)\n                                    // const authorizedState = { ...this.state }\n                                    // for (let path of this.storageOptions.privateStatePaths) {\n                                    //     delete authorizedState[path]\n                                    // }\n                                    localStorage.setItem(this.storageOptions.name, JSON.stringify(authorizedState))\n                                } else {\n                                    localStorage.setItem(this.storageOptions.name, JSON.stringify(this.state))\n                                }\n                            }\n                            callback(this.state)\n                            resolve(this.state)\n                        })\n                    })\n                }\n\n                this.setState = this.setState.bind(this);\n            }\n\n            generateDispatchers(reducers) {\n                const reducersWithDispatchers = {}\n\n                // define a dispatcher factory to handle the creation of new dispatchers\n                const dispatcherFactory = function (reducerKey) {\n                    return function (state, action) {\n                        this.setState(this.reducers[reducerKey](state, action))\n                    }\n                }\n\n                let dispatch;\n                for (let reducer in reducers) {\n                    dispatch = dispatcherFactory(reducer).bind(this);\n                    reducersWithDispatchers[reducer] = { dispatch }\n                }\n\n                return reducersWithDispatchers\n            }\n\n            updateStateFromLocalStorage() {\n\n                try {\n                    this.setState({ ...this.state, ...JSON.parse(window.localStorage.getItem(storageOptions.name)) })\n                } catch (err) { // bug check: is this still needed?\n                    const updatedState = typeof localStorage[storageOptions.name] === \"string\"\n                        ?\n                        { ...this.state, ...JSON.parse(localStorage[storageOptions.name]) }\n                        :\n                        { ...this.state }\n\n                    this.setState(updatedState)\n                }\n            }\n\n            createWindowManager() {\n\n                // storage object for opened child windows\n                this.windows = this.windows || {};\n\n                // window manager methods passed to user\n                const windowManagerMethods = {\n                    open(url, name, params = {}) {\n                        this.windows[name] = window.open(url, name, createParamsString(params))\n                    },\n                    close(name) {\n                        if (this.windows[name]) {\n                            this.windows[name].close();\n                        }\n                        delete this.windows[name]\n                    },\n                    getChildren() {\n                        return this.windows;\n                    }\n                }\n\n\n\n\n                // instruct the window what to do when it closes\n                // we define this here, and not up in the CantusFirmus class because we need access to all generated child windows\n                if (window.name === storageOptions.providerWindow || storageOptions.removeChildrenOnUnload) {\n                    function handleUnload(e) {\n\n                        // clear local storage only if specified by user AND the window being closed is the provider window \n                        if (storageOptions.clearStorageOnUnload && storageOptions.providerWindow === window.name) {\n                            localStorage.removeItem(storageOptions.name)\n                        }\n\n                        // close all children (and grand children) windows if this functionality has been specified by the user\n                        if (storageOptions.removeChildrenOnUnload) {\n                            for (let w of Object.keys(this.windows)) {\n                                this.windows[w].close()\n                            }\n                        }\n\n                        // return \"uncomment to debug unload functionality\"\n                    }\n\n                    handleUnload = handleUnload.bind(this)\n\n                    // set the unload functionality\n                    window.onbeforeunload = handleUnload\n                    window.onunload = handleUnload\n                }\n\n\n\n                // bind methods to 'this'\n                return bindMethods(windowManagerMethods, this)\n\n            }\n\n            componentDidMount() {\n\n                // When component mounts, if bindToLocalStorage has been set to true, make the window listen for storage change events and update the state \n                // if the window is already listening for storage events, then do nothing\n                if (bindToLocalStorage && !window.onstorage) {\n                    window.onstorage = e => {\n                        console.log(\"ON STORAGE FIRED\")\n                        this.updateStateFromLocalStorage();\n                    }\n                }\n            }\n\n            componentDidUpdate(prevProps, prevState) {\n                // Object.entries(this.props).forEach(([key, val]) =>\n                //     prevProps[key] !== val && console.log(`Prop '${key}' changed`)\n                // );\n                // if (this.state) {\n                //     Object.entries(this.state).forEach(([key, val]) =>\n                //         prevState[key] !== val && console.log(`State '${key}' changed`)\n                //     );\n                // }\n            }\n\n\n\n            render() {\n\n                const value = {\n                    state: this.state,\n                    setters: this.setters,\n                    getters: this.getters,\n                    methods: this.methods,\n                    constants,\n                    ...this._boundNamespacedMethods, // expand any namespaced methods into the distributed value\n                }\n\n                // add reducers with dispatchers\n                if (Object.keys(reducers).length) value.reducers = this.reducersWithDispatchers\n\n                // initialize a window manager if within a multi-window state management system\n                if (this.bindToLocalStorage) value.windowManager = this.createWindowManager();\n\n                // rename value keys to user specifications\n                for (let key of Object.keys(renameMap)) {\n                    if (value[key]) {\n                        value[renameMap[key]] = value[key];\n                        delete value[key];\n                        // reassign the value in 'this' for reference in across method types (setters, methods, etc.)\n                        this[renameMap[key]] = this[key];\n                    }\n                }\n\n                return (\n                    <Context.Provider value={value}>\n                        {this.props.children}\n                    </Context.Provider>\n                )\n            }\n        }\n\n        // return provider class\n        return Provider;\n    }\n}\n\nexport default CantusFirmus;\n\n\n\n\n// ============================ Subscribe ============================\n\n/* \ncontextDependencies = [\n    {context: Context, key: string name of context in props, dependencies: [string names of deps]},\n    ...\n]\n */\n\nexport const subscribe = (Component, contextDependencies) => {\n\n    const CantusFirmusSubscriber = (props) => {\n\n        let contexts = {},\n            dependencies = [],\n            nestedDep = null;\n\n        // apply default key value when only 1 context is subscribed to, and no key value given\n        if (contextDependencies.length === 1 && !contextDependencies[0].key) contextDependencies[0].key = \"context\"\n\n        for(let [ctx, i] of Object.entries(contextDependencies)){\n            i = parseInt(i)\n            ctx.key = ctx.key || `context${i + 1}` // if not key value is set, apply default here\n            contexts[ctx.key] = useContext(ctx.context); // assign the entire context object so it can be passed into props\n\n            for (let dep of ctx.dependencies) {\n\n                if (typeof dep === \"string\") {\n\n                    dependencies.push(contexts[ctx.key].state[dep]) // save just the desired state dependencies\n\n                } else if (Array.isArray(dep)) { // allow for nested dependencies\n\n                    nestedDep = contexts[ctx.key].state[dep[0]]\n                    for (let i = 1; i < dep.length; i++) { // looping from 1 because we have already handled the first step in the nested path\n                        nestedDep = nestedDep[dep[i]]\n                    }\n                    dependencies.push(nestedDep)\n\n                }\n            }\n        }\n\n\n        // add props to dependencies\n        for (let propKey of Object.keys(props)) {\n            dependencies.push(props[propKey])\n        }\n\n        return useMemo(\n            () => <Component {...props} {...contexts} />,\n            dependencies\n        )\n    }\n\n    return CantusFirmusSubscriber;\n\n\n}\n\n",{"ruleId":"86","replacedBy":"87"},{"ruleId":"88","replacedBy":"89"},{"ruleId":"90","severity":1,"message":"91","line":1,"column":1,"nodeType":"92","messageId":"93","endLine":1,"endColumn":14,"fix":"94"},{"ruleId":"95","severity":1,"message":"96","line":12,"column":114,"nodeType":"97","messageId":"98","endLine":12,"endColumn":138},{"ruleId":"99","severity":1,"message":"100","line":14,"column":101,"nodeType":"101","messageId":"102","endLine":14,"endColumn":103},{"ruleId":"99","severity":1,"message":"100","line":14,"column":128,"nodeType":"101","messageId":"102","endLine":14,"endColumn":130},{"ruleId":"95","severity":1,"message":"103","line":16,"column":23,"nodeType":"97","messageId":"98","endLine":16,"endColumn":31},{"ruleId":"95","severity":1,"message":"104","line":28,"column":34,"nodeType":"97","messageId":"98","endLine":28,"endColumn":49},{"ruleId":"95","severity":1,"message":"105","line":38,"column":31,"nodeType":"97","messageId":"98","endLine":38,"endColumn":46},{"ruleId":"99","severity":1,"message":"100","line":50,"column":195,"nodeType":"101","messageId":"102","endLine":50,"endColumn":197},{"ruleId":"99","severity":1,"message":"100","line":50,"column":218,"nodeType":"101","messageId":"102","endLine":50,"endColumn":220},{"ruleId":"106","severity":1,"message":"107","line":54,"column":185,"nodeType":"108","messageId":"109","endLine":54,"endColumn":246},{"ruleId":"106","severity":1,"message":"107","line":54,"column":412,"nodeType":"108","messageId":"109","endLine":54,"endColumn":512},{"ruleId":"95","severity":1,"message":"110","line":70,"column":127,"nodeType":"97","messageId":"98","endLine":70,"endColumn":134},{"ruleId":"95","severity":1,"message":"110","line":70,"column":192,"nodeType":"97","messageId":"98","endLine":70,"endColumn":199},{"ruleId":"111","severity":2,"message":"112","line":187,"column":53,"nodeType":"97","messageId":"113","endLine":187,"endColumn":71},{"ruleId":"111","severity":2,"message":"112","line":193,"column":18,"nodeType":"97","messageId":"113","endLine":193,"endColumn":36},{"ruleId":"114","severity":1,"message":"115","line":195,"column":15,"nodeType":"116","messageId":"117","endLine":264,"endColumn":16},{"ruleId":"106","severity":1,"message":"118","line":204,"column":79,"nodeType":"108","messageId":"109","endLine":229,"endColumn":20},{"ruleId":"111","severity":2,"message":"112","line":205,"column":65,"nodeType":"97","messageId":"113","endLine":205,"endColumn":83},{"ruleId":"111","severity":2,"message":"112","line":206,"column":30,"nodeType":"97","messageId":"113","endLine":206,"endColumn":48},{"ruleId":"114","severity":1,"message":"115","line":208,"column":27,"nodeType":"116","messageId":"117","endLine":221,"endColumn":28},{"ruleId":"119","severity":1,"message":"120","line":218,"column":29,"nodeType":"121","messageId":"122","endLine":218,"endColumn":36},{"ruleId":"106","severity":1,"message":"123","line":234,"column":79,"nodeType":"108","messageId":"109","endLine":259,"endColumn":20},{"ruleId":"111","severity":2,"message":"112","line":235,"column":65,"nodeType":"97","messageId":"113","endLine":235,"endColumn":83},{"ruleId":"111","severity":2,"message":"112","line":236,"column":30,"nodeType":"97","messageId":"113","endLine":236,"endColumn":48},{"ruleId":"114","severity":1,"message":"115","line":238,"column":27,"nodeType":"116","messageId":"117","endLine":251,"endColumn":28},{"ruleId":"119","severity":1,"message":"120","line":248,"column":29,"nodeType":"121","messageId":"122","endLine":248,"endColumn":36},{"ruleId":"111","severity":2,"message":"112","line":296,"column":56,"nodeType":"97","messageId":"113","endLine":296,"endColumn":74},{"ruleId":"111","severity":2,"message":"112","line":300,"column":22,"nodeType":"97","messageId":"113","endLine":300,"endColumn":40},{"ruleId":"114","severity":1,"message":"115","line":302,"column":19,"nodeType":"116","messageId":"117","endLine":336,"endColumn":20},{"ruleId":"106","severity":1,"message":"124","line":306,"column":83,"nodeType":"108","messageId":"109","endLine":331,"endColumn":24},{"ruleId":"111","severity":2,"message":"112","line":307,"column":69,"nodeType":"97","messageId":"113","endLine":307,"endColumn":87},{"ruleId":"111","severity":2,"message":"112","line":308,"column":34,"nodeType":"97","messageId":"113","endLine":308,"endColumn":52},{"ruleId":"114","severity":1,"message":"115","line":310,"column":31,"nodeType":"116","messageId":"117","endLine":323,"endColumn":32},{"ruleId":"119","severity":1,"message":"120","line":320,"column":33,"nodeType":"121","messageId":"122","endLine":320,"endColumn":40},{"ruleId":"125","severity":1,"message":"126","line":479,"column":5,"nodeType":"97","messageId":"127","endLine":479,"endColumn":29},{"ruleId":"125","severity":1,"message":"126","line":212,"column":7,"nodeType":"97","messageId":"127","endLine":212,"endColumn":31},{"ruleId":"95","severity":1,"message":"128","line":562,"column":21,"nodeType":"97","messageId":"98","endLine":562,"endColumn":33},{"ruleId":"129","severity":2,"message":"130","line":669,"column":33,"nodeType":"97","endLine":669,"endColumn":43},{"ruleId":"131","severity":1,"message":"132","line":697,"column":13,"nodeType":"97","endLine":697,"endColumn":25},{"ruleId":"131","severity":1,"message":"133","line":697,"column":13,"nodeType":"97","endLine":697,"endColumn":25,"suggestions":"134"},"no-native-reassign",["135"],"no-negated-in-lhs",["136"],"strict","'use strict' is unnecessary inside of modules.","ExpressionStatement","module",{"range":"137","text":"138"},"no-func-assign","'_getRequireWildcardCache' is a function.","Identifier","isAFunction","no-mixed-operators","Unexpected mix of '||' and '&&'.","LogicalExpression","unexpectedMixedOperator","'_extends' is a function.","'_setPrototypeOf' is a function.","'_getPrototypeOf' is a function.","no-loop-func","Function declared in a loop contains unsafe references to variable(s) 'source'.","FunctionExpression","unsafeRefs","'_typeof' is a function.","no-undef","'regeneratorRuntime' is not defined.","undef","default-case","Expected a default case.","SwitchStatement","missingDefaultCase","Function declared in a loop contains unsafe references to variable(s) 'regeneratorRuntime', 'regeneratorRuntime', 'cb'.","no-fallthrough","Expected a 'break' statement before 'case'.","SwitchCase","case","Function declared in a loop contains unsafe references to variable(s) 'regeneratorRuntime', 'regeneratorRuntime', 'newState', 'cb'.","Function declared in a loop contains unsafe references to variable(s) 'regeneratorRuntime', 'regeneratorRuntime', 'newState'.","no-unused-vars","'createReducerDispatchers' is assigned a value but never used.","unusedVar","'handleUnload' is a function.","react-hooks/rules-of-hooks","React Hook \"useContext\" may be executed more than once. Possibly because it is called in a loop. React Hooks must be called in the exact same order in every component render.","react-hooks/exhaustive-deps","React Hook useMemo was passed a dependency list that is not an array literal. This means we can't statically verify whether you've passed the correct dependencies.","React Hook useMemo has missing dependencies: 'contexts' and 'props'. Either include them or remove the dependency array.",["139"],"no-global-assign","no-unsafe-negation",[0,13],"",{"desc":"140","fix":"141"},"Update the dependencies array to be: [contexts, props]",{"range":"142","text":"143"},[25822,25834],"[contexts, props]"]